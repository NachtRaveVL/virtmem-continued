<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>virtmem: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">virtmem
   </div>
   <div id="projectbrief">virtual memory library for Arduino</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">virtmem Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro">Introduction</a></li>
<li class="level1"><a href="#features">Features</a></li>
<li class="level1"><a href="#demo">Demonstration</a></li>
<li class="level1"><a href="#basics">Basics</a><ul><li class="level2"><a href="#bVirtmem">Virtual memory</a></li>
<li class="level2"><a href="#bUsing">Using virtual memory</a></li>
</ul>
</li>
<li class="level1"><a href="#advanced">Advanced</a><ul><li class="level2"><a href="#aLocking">Locking virtual data</a><ul><li class="level3"><a href="#alPages">Note on memory pages</a></li>
<li class="level3"><a href="#alUsing">Using virtual data locks</a></li>
</ul>
</li>
<li class="level2"><a href="#aAccess">Accessing data in virtual memory</a></li>
<li class="level2"><a href="#aWrapping">Wrapping regular pointers</a></li>
<li class="level2"><a href="#aMultiAlloc">Multiple allocators</a></li>
<li class="level2"><a href="#aConfigAlloc">Configuring allocators</a></li>
<li class="level2"><a href="#aPointStructMem">Virtual pointers to `struct`/`class` data members</a></li>
<li class="level2"><a href="#aCoverloads">Overloads of some common C library functions for virtual pointers</a></li>
<li class="level2"><a href="#aTypeless">Typeless virtual pointers (analog to void*)</a></li>
</ul>
</li>
<li class="level1"><a href="#examples">Examples</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p><code>virtmem</code> is an Arduino library that allows your project to easily use an external memory source to extend the (limited) amount of available RAM. This library supports several memory resources, for instance, SPI ram (e.g. the <code>23LC1024</code> chip from Microchip), an SD card or even a computer connected via a serial connection. The library is made in such a way that managing and using this <em>virtual memory</em> closely resembles working with data from 'normal' memory.</p>
<h1><a class="anchor" id="features"></a>
Features</h1>
<ul>
<li>Extend the available memory with kilobytes, megabytes or even gigabytes</li>
<li>Supports SPI RAM (23LC series from Microchip), SD cards and RAM from a computer connected through serial</li>
<li>Easy C++ interface that closely resembles regular data access</li>
<li>Memory page system to speed up access to virtual memory</li>
<li>New memory interfaces can be added easily</li>
<li>Code is mostly platform independent and can fairly easy be ported to other plaforms (x86 port exists for debugging)</li>
</ul>
<h1><a class="anchor" id="demo"></a>
Demonstration</h1>
<p>Before delving into specifics, here is a simple example to demonstrate how <code>virtmem</code> works and what it can do.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Arduino.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;SdFat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="virtmem_8h.html">virtmem.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sdfatlib__alloc_8h.html">sdfatlib_alloc.h</a>&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Simplify virtmem usage</span></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacevirtmem.html">virtmem</a>;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create virtual a memory allocator that uses SD card (with FAT filesystem) as virtual memory pool</span></div>
<div class="line"><span class="comment">// The default memory pool size (1 MB) is used.</span></div>
<div class="line"><a class="code" href="singletonvirtmem_1_1CSdfatlibVirtMemAlloc.html">CSdfatlibVirtMemAlloc&lt;&gt;</a> valloc;</div>
<div class="line"></div>
<div class="line">SdFat sd;</div>
<div class="line"></div>
<div class="line"><span class="keyword">struct </span>MyStruct { <span class="keywordtype">int</span> x, y; };</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> setup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize SdFatlib</span></div>
<div class="line">    <span class="keywordflow">if</span> (!sd.begin(9, SPI_FULL_SPEED))</div>
<div class="line">        sd.initErrorHalt();</div>
<div class="line"></div>
<div class="line">    valloc.<a class="code" href="classvirtmem_1_1CBaseVirtMemAlloc.html#a1682f8a05e7b5cf360c4191e5751d46c">start</a>(); <span class="comment">// Always call this to initialize the allocator before using it</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Allocate a char buffer of 10000 bytes in virtual memory and store the address to a virtual pointer</span></div>
<div class="line">    <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">TSdfatlibVirtPtr&lt;char&gt;::type</a> str = str.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>(10000);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Set the first 1000 bytes to &#39;A&#39;</span></div>
<div class="line">    memset(str, <span class="charliteral">&#39;A&#39;</span>, 1000);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// array access</span></div>
<div class="line">    str[1] = <span class="charliteral">&#39;B&#39;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Own types (structs/classes) also work.</span></div>
<div class="line">    <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">TSdfatlibVirtPtr&lt;MyStruct&gt;::type</a> ms = ms.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>(); <span class="comment">// alloc call without parameters: use automatic size deduction</span></div>
<div class="line">    ms-&gt;x = 5;</div>
<div class="line">    ms-&gt;y = 15;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> loop()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This Arduino sketch demonstrates how to use a SD card as virtual memory store. By using a virtual memory pointer wrapper class, using virtual memory becomes quite close to using data residing in 'normal' memory.</p>
<h1><a class="anchor" id="basics"></a>
Basics</h1>
<h2><a class="anchor" id="bVirtmem"></a>
Virtual memory</h2>
<p>As the name suggests, <code>virtmem</code> works similar to <a href="https://en.wikipedia.org/wiki/Virtual_memory">virtual memory management found on computers</a>.</p>
<p>The library uses a <em>paging system</em> to work efficiently with virtual memory. A <em>memory page</em> is a static buffer that resides in regular RAM and contains a copy of a part of the total virtual memory pool. Multiple pages are typically used (usually four), where each page contains a copy of a different virtual memory region. Similar to data allocated from the heap, data access from virtual memory happens through a <em>virtual pointer</em>.</p>
<div class="image">
<img src="intro-scheme.png" alt="intro-scheme.png"/>
<div class="caption">
virtual memory scheme</div></div>
<p> Whenever a virtual pointer is dereferenced, the library first checks whether the requested data resides in one of the memory pages, and if not, the library will copy the data from virtual memory to a suitable memory page. All data access now happens through this memory page.</p>
<p>When virtual memory has to be copied to a memory page and no pages are free, the library will first have to free a page. During this process any modified data will be written back to the virtual memory pool and the requested data will be loaded to the page. This process is sometimes called <em>swapping</em>. Swapping a page is generally a relative time consuming process, since a large amount of data has to be transferred for example over SPI. To minimize swapping, the library always tries to free pages that were not recently loaded in (FIFO like). The time spent on swapping is further reduced by having multiple memory pages and only writing out data that was modified.</p>
<p>Because memory pages reside in regular RAM, (repeated) data access to paged memory is quite fast.</p>
<h2><a class="anchor" id="bUsing"></a>
Using virtual memory</h2>
<p>Virtual memory in <code>virtmem</code> is managed by a virtual memory allocator. These are C++ template classes which are responsible for allocating and releasing virtual memory and contain the datablocks utilized for memory pages. Most of this functionality is defined in the <a class="el" href="classvirtmem_1_1CBaseVirtMemAlloc.html" title="Base class for virtual memory allocators. ">virtmem::CBaseVirtMemAlloc</a> and <a class="el" href="classvirtmem_1_1CVirtMemAlloc.html" title="Base template class for virtual memory allocators. ">virtmem::CVirtMemAlloc</a> classes. In addition to this, several allocator classes are derived from these base classes that actually implement the code necessary to deal with virtual memory (e.g. reading and writing data). For example, the class <a class="el" href="singletonvirtmem_1_1CSdfatlibVirtMemAlloc.html">virtmem::CSdfatlibVirtMemAlloc</a> implements an allocator that uses an SD card as a virtual memory pool.</p>
<p>The <code>virtmem</code> library supports the following allocators:</p><ul>
<li><a class="el" href="singletonvirtmem_1_1CSdfatlibVirtMemAlloc.html">virtmem::CSdfatlibVirtMemAlloc</a>: uses a FAT formatted SD card as memory pool</li>
<li><a class="el" href="classvirtmem_1_1CSPIRAMVirtMemAlloc.html">virtmem::CSPIRAMVirtMemAlloc</a>: uses SPI ram (Microchip's 23LC series) as memory pool</li>
<li><a class="el" href="classvirtmem_1_1CMultiSPIRAMVirtMemAlloc.html">virtmem::CMultiSPIRAMVirtMemAlloc</a>: like <a class="el" href="classvirtmem_1_1CSPIRAMVirtMemAlloc.html">virtmem::CSPIRAMVirtMemAlloc</a>, but supports multiple memory chips</li>
<li><a class="el" href="classvirtmem_1_1CSerRAMVirtMemAlloc.html">virtmem::CSerRAMVirtMemAlloc</a>: uses RAM from a computer connected through serial as memory pool</li>
<li>For debugging there is also <a class="el" href="classvirtmem_1_1CStaticVirtMemAlloc.html">virtmem::CStaticVirtMemAlloc</a> (uses regular RAM as memory pool) and <a class="el" href="singletonvirtmem_1_1CStdioVirtMemAlloc.html">virtmem::CStdioVirtMemAlloc</a> (uses files through regular stdio functions as memory pool)</li>
</ul>
<p>Note that all allocator classes are <em>singleton</em>, meaning that only one (global) instance should be defined (however, instances of <em>different</em> allocators can co-exist, see <a class="el" href="index.html#aMultiAlloc">Multiple allocators</a>).</p>
<p>After defining a (global) instance of the allocator of choice, one of the first things to do is to initialize it:</p>
<div class="fragment"><div class="line"><span class="comment">// Create a virtual memory allocator that uses SD card (with FAT filesystem) as virtual memory pool</span></div>
<div class="line"><span class="comment">// The default memory pool size (1 MB) is used.</span></div>
<div class="line"><a class="code" href="singletonvirtmem_1_1CSdfatlibVirtMemAlloc.html">virtmem::CSdfatlibVirtMemAlloc&lt;&gt;</a> valloc;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> setup()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Initialize SdFatlib</span></div>
<div class="line"></div>
<div class="line">    valloc.<a class="code" href="classvirtmem_1_1CBaseVirtMemAlloc.html#a1682f8a05e7b5cf360c4191e5751d46c">start</a>(); <span class="comment">// Always call this to initialize the allocator before using it</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>Please note that, since this example uses the SD fat lib allocator, SD fat lib has to be initialized prior to the allocator (see <a class="el" href="singletonvirtmem_1_1CSdfatlibVirtMemAlloc.html">virtmem::CSdfatlibVirtMemAlloc</a>).</p>
<p>Two interfaces exist to actually use virtual memory.</p>
<p>The first approach is to use interface with raw memory directly through functions defined in <a class="el" href="classvirtmem_1_1CBaseVirtMemAlloc.html" title="Base class for virtual memory allocators. ">virtmem::CBaseVirtMemAlloc</a> (e.g. <a class="el" href="classvirtmem_1_1CBaseVirtMemAlloc.html#a895e8ee2cf1019d3d069762ec7785540">read()</a> and <a class="el" href="classvirtmem_1_1CBaseVirtMemAlloc.html#ace52c23506209528513472e4661e5fe7">write()</a>). Although dealing with raw memory might be slightly more efficient performance wise, this approach is not recommended as it is fairly cumbersome to do so.</p>
<p>The second approach is to use <em>virtual pointer wrappers</em>. These template classes were designed to make virtual memory access as close as 'regular' memory access as possible. Here is an example:</p>
<div class="fragment"><div class="line"><span class="comment">// define virtual pointer linked to SD fat memory</span></div>
<div class="line"><a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::CVirtPtr&lt;int, virtmem::CSdfatlibVirtMemAlloc&gt;</a> vptr;</div>
<div class="line"><span class="comment">// virtmem::TSdfatlibVirtPtr&lt;int&gt;::type vptr; // same, but slightly shorter syntax</span></div>
<div class="line"></div>
<div class="line">vptr = vptr.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>(); <span class="comment">// allocate memory to store integer (size automatically deduced from type)</span></div>
<div class="line">*vptr = 4;</div>
</div><!-- fragment --><p>In this example we defined a virtual pointer to an <code>int</code>. Defining virtual pointer variables can be done straight from <a class="el" href="singletonvirtmem_1_1CVirtPtr.html" title="Virtual pointer class that provides an interface to access virtual much like &#39;regular pointers&#39;...">virtmem::CVirtPtr</a> or from one of the shortcut helper classes (such as <a class="el" href="structvirtmem_1_1TSdfatlibVirtPtr.html">virtmem::TSdfatlibVirtPtr</a>). Either do the same.</p>
<p>Memory allocation (<a class="el" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc()</a>) is done through a (static) function defined in the virtual pointer class. In the above example no arguments were passed to <a class="el" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc()</a>, which means that <code>alloc</code> will automatically deduce the size required for the pointer type (<code>int</code>). If you want to allocate a different size (for instance to use the data as an array) then the number of bytes should be specified as the first argument to <code>alloc</code>:</p>
<div class="fragment"><div class="line">vptr = vptr.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>(1000 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>)); <span class="comment">// allocate memory to store array of 1000 integers</span></div>
<div class="line">vptr[500] = 1337;</div>
</div><!-- fragment --><p>Besides all standard types (char, int, short, etc.), virtual pointers can also work with custom types (structs/classes):</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyStruct { <span class="keywordtype">int</span> x, y; };</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line">TSdfatlibVirtPtr&lt;MyStruct&gt;::type ms = ms.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>();</div>
<div class="line">ms-&gt;x = 5;</div>
<div class="line">ms-&gt;y = 15;</div>
</div><!-- fragment --><p> Note that there are a few imitations when using structs (or classes) with <code>virtmem</code>. For details: see <a class="el" href="singletonvirtmem_1_1CVirtPtr.html" title="Virtual pointer class that provides an interface to access virtual much like &#39;regular pointers&#39;...">virtmem::CVirtPtr</a>.</p>
<p>Finally, to free memory the <a class="el" href="singletonvirtmem_1_1CVirtPtr.html#aed7594b4c0f00138dd0ff24e2c99b5ef">free()</a> function can be used:</p>
<div class="fragment"><div class="line">vptr.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#aed7594b4c0f00138dd0ff24e2c99b5ef">free</a>(vptr); <span class="comment">// memory size is automatically deduced</span></div>
</div><!-- fragment --><p>For further info see <a class="el" href="classvirtmem_1_1CBaseVirtPtr.html" title="This is the base class of CVirtPtr and can be used for typeless pointers. ">virtmem::CBaseVirtPtr</a> and <a class="el" href="singletonvirtmem_1_1CVirtPtr.html" title="Virtual pointer class that provides an interface to access virtual much like &#39;regular pointers&#39;...">virtmem::CVirtPtr</a>.</p>
<h1><a class="anchor" id="advanced"></a>
Advanced</h1>
<h2><a class="anchor" id="aLocking"></a>
Locking virtual data</h2>
<p>A portion of the virtual memory can be locked to a memory page. Whenever such a lock is made, the data is <em>guaranteed</em> to stay in a memory page and will not be swapped out. The same data can be locked multiple times, and the data may only be swapped when all locks are released.</p>
<p>One reason to lock data is to improve performance. As soon as data is locked it can safely be accessed through a regular pointer, meaning that no additional overhead exists to use the data.</p>
<p>Another reason to lock data is to work with code that only accepts data residing in regular memory space. For instance, if a function needs to be called that requires a pointer to the data, the pointer to the locked memory page region can then be passed to such a function.</p>
<h3><a class="anchor" id="alPages"></a>
Note on memory pages</h3>
<p>Each virtual data lock will essentially block a memory page. Since the number of memory pages is rather small, care should be taken to not to create too many different data locks.</p>
<p>To decrease the likelyhood of running out of free memory pages, <code>virtmem</code> supports two additional sets of smaller memory pages which are specifically used for data locking. They are much smaller in size, so they will not use a large deal of RAM, while still providing extra capacity for smaller data locks. Having a set of smaller memory pages is especially useful for <a class="el" href="index.html#aAccess">locks created when accessing data in structures/classes</a>.</p>
<p>The default size and amount of memory pages is dependent upon the MCU platform and can be customized as described in <a class="el" href="index.html#aConfigAlloc">Configuring allocators</a>.</p>
<h3><a class="anchor" id="alUsing"></a>
Using virtual data locks</h3>
<p>To create a lock to virtual memory the <a class="el" href="classvirtmem_1_1CVirtPtrLock.html" title="Creates a lock to some virtual data. ">virtmem::CVirtPtrLock</a> class is used:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::TSdfatlibVirtPtr&lt;char&gt;::type</a> virtCharPtr; <span class="comment">// shortcut</span></div>
<div class="line">virtCharPtr vptr = vptr.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>(100); <span class="comment">// allocate some virtual memory</span></div>
<div class="line"><a class="code" href="classvirtmem_1_1CVirtPtrLock.html">virtmem::CVirtPtrLock&lt;virtCharPtr&gt;</a> lock = virtmem::makeVirtPtrLock(vptr, 100, <span class="keyword">false</span>);</div>
<div class="line">memset(*lock, 10, 100); <span class="comment">// set all bytes to &#39;10&#39;</span></div>
</div><!-- fragment --><p>The virtmem::makeVirtPtrLock function is used to create a lock. The last parameter to this function (optional, by default <code>false</code>) tells whether the locked data should be treated as read-only: if set to <code>false</code> the data will be written back to the virtual memory (even if unchanged). If you know the data will not be changed (or you don't care about changes), then it's more efficient to pass <code>true</code> instead.</p>
<p>Accessing locked data is simply done by dereferencing the lock variable (i.e. <code>*lock</code>).</p>
<p>Sometimes it is not possible to completely lock the memory region that was requested. For instance, there may not be sufficient space available to lock the complete data to a memory page or there will be overlap with another locked memory region. For this reason, it is <b>important to always check the <em>actual size</em> that was locked</b>. After a lock has been made, the effective size of the locked region can be requested by the <a class="el" href="classvirtmem_1_1CVirtPtrLock.html#ae9608b7742f952c443d88a2e190ffc3d" title="Returns the actual size locked. ">virtmem::CVirtPtrLock::getLockSize()</a> function. Because it is rather unpredictable whether the requested data can be locked in one go, it is best create a loop that iteratively creates locks until all bytes have been dealt with:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::TSdfatlibVirtPtr&lt;char&gt;::type</a> virtCharPtr; <span class="comment">// shortcut</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> size = 10000;</div>
<div class="line"><span class="keywordtype">int</span> sizeleft = size;</div>
<div class="line"></div>
<div class="line">virtCharPtr vptr = vptr.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#affa1cd2dfa4d2fe901dc055686aff579">alloc</a>(size); <span class="comment">// allocate a large block of virtual memory</span></div>
<div class="line">virtCharPtr p = vptr;</div>
<div class="line"></div>
<div class="line"><span class="keywordflow">while</span> (sizeleft)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// create a lock to (a part) of the buffer</span></div>
<div class="line">    <a class="code" href="classvirtmem_1_1CVirtPtrLock.html">virtmem::CVirtPtrLock&lt;virtCharPtr&gt;</a> lock = virtmem::makeVirtPtrLock(p, sizeleft, <span class="keyword">false</span>);</div>
<div class="line"></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> lockedsize = lock.<a class="code" href="classvirtmem_1_1CVirtPtrLock.html#ae9608b7742f952c443d88a2e190ffc3d">getLockSize</a>(); <span class="comment">// get the actual size of the memory block that was locked</span></div>
<div class="line">    memset(*l, 10, lockedsize);</div>
<div class="line"></div>
<div class="line">    p += lockedsize; <span class="comment">// increase pointer to next block to lock</span></div>
<div class="line">    sizeleft -= lockedsize; <span class="comment">// decrease number of bytes to still lock</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> Note that a <code>memset</code> overload is provided by <code>virtmem</code> which works with virtual pointers.</p>
<p>After you are finished working with a virtual memory lock it has to be released. This can be done manually with the <a class="el" href="classvirtmem_1_1CVirtPtrLock.html#a2b45db1e693021c9869eacac594bec7a" title="Unlocks data (if locked). Automatically called during destruction. ">virtmem::CVirtPtrLock::unlock</a> function. However, the <a class="el" href="classvirtmem_1_1CVirtPtrLock.html" title="Creates a lock to some virtual data. ">virtmem::CVirtPtrLock</a> destructor will call this function automatically (the class follows the <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII principle</a>). This explains why calling <code>unlock()</code> in the above example was not necessary, as the destructor will call it automatically when the <code>lock</code> variable goes out of scope at the end of every iteration.</p>
<h2><a class="anchor" id="aAccess"></a>
Accessing data in virtual memory</h2>
<dl class="section note"><dt>Note</dt><dd>This section is mostly theoretical. If you are skimming this manual (or lazy), you can skip this section.</dd></dl>
<p>Whenever virtual data is accessed, <code>virtmem</code> first has to make sure that this data resides in regular RAM (i.e. a memory page). In addition, if the data is changed, <code>virtmem</code> has to flag this data as 'dirty' so that it will be synchronized during the next page swap. To achieve these tasks, <code>virtmem</code> returns a <em>proxy class</em> whenever a virtual pointer is dereferenced, instead of returning the actual data. This proxy class (<a class="el" href="classvirtmem_1_1CVirtPtr_1_1CValueWrapper.html">virtmem::CVirtPtr::CValueWrapper</a>) acts as it is the actual data, and is mostly invisible to the user:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> x = *myIntVptr;</div>
<div class="line">*myIntVptr = 55;</div>
</div><!-- fragment --><p>The first line of the above example demonstrates a read operation: in this case the proxy class (returned by <code>*myIntVPtr</code>) will be converted to an int (automatic type cast), during which it will return a copy the data from virtual memory. The second line is a write operation: here the proxy class signals <code>virtmem</code> that data is changed and needs to be synchronized during the next page swap.</p>
<p>For accessing data members of structures (everything discussed here also applies to classes) in virtual memory the situation is more complicated. When a member is accessed through the <code>-&gt;</code> operator of of the virtual pointer, we <a href="http://stackoverflow.com/a/8782794">must return an actual pointer to the structure</a>. While it is possible to make this data available through a memory page (as is done normally) in the <code>-&gt;</code> overload function, synchronizing the data back is more tricky. For this reason, another proxy class is used (<a class="el" href="classvirtmem_1_1CVirtPtr_1_1CMemberWrapper.html">virtmem::CVirtPtr::CMemberWrapper</a>) which is returned when the <code>-&gt;</code> operator is called. This proxy class has also its <code>-&gt;</code> operator overloaded, and this overload returns the actual data. The lifetime of this proxy class is important and matches that of the lifetime the data needs to be available in a memory page (for more details, see <a href="http://www.stroustrup.com/wrapper.pdf">Stroustrup's general wrapper paper</a>). Following from this, the proxy class will create a <a class="el" href="index.html#aLocking">data lock</a> to the data of the structure during construction and release this lock during its destruction.</p>
<h2><a class="anchor" id="aWrapping"></a>
Wrapping regular pointers</h2>
<p>Sometimes it may be handy to assign a regular pointer to a virtual pointer: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::TSdfatlibVirtPtr&lt;int&gt;::type</a> virtIntPtr; <span class="comment">// shortcut</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">void</span> f(virtIntPtr p, <span class="keywordtype">int</span> x)</div>
<div class="line">{</div>
<div class="line">    *p += x;</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">*vptr = 55; <span class="comment">// vptr is a virtual pointer to int</span></div>
<div class="line">*ptr = 66; <span class="comment">// ptr is a regular pointer to int (i.e. int*)</span></div>
<div class="line"></div>
<div class="line">f(vptr, 10);</div>
<div class="line">f(ptr, 12); <span class="comment">// ERROR! Function only accepts virtual pointers</span></div>
</div><!-- fragment --><p>In the above example we have a (nonsensical) function <code>f</code> which only accepts virtual pointers. Hence, the final line in this example will fail. Of course we could overload this function and provide an implementation that supports regular pointers. Alternatively, you can also 'wrap' the regular pointer inside a virtual pointer:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::TSdfatlibVirtPtr&lt;int&gt;::type</a> virtIntPtr; <span class="comment">// shortcut</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line">*ptr = 66; <span class="comment">// ptr is a regular pointer to int (i.e. int*)</span></div>
<div class="line">virtIntPtr myvptr = myvptr.<a class="code" href="singletonvirtmem_1_1CVirtPtr.html#aeaa6e1f86e7ee7301163b4a58dc683be">wrap</a>(ptr); <span class="comment">// &#39;wrap&#39; ptr inside a virtual pointer</span></div>
<div class="line"></div>
<div class="line">f(myvptr, 12); <span class="comment">// Success!</span></div>
</div><!-- fragment --><p>If you want to obtain the original pointer then you can use the <a class="el" href="singletonvirtmem_1_1CVirtPtr.html#a8eb976a8c6b69ffc8956e009479969de">unwrap()</a> function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *myptr = vptr.unwrap();</div>
</div><!-- fragment --><p>Please note that calling <code>unwrap()</code> on a non-wrapped virtual pointer yields an invalid pointer address. To avoid this, the <a class="el" href="classvirtmem_1_1CBaseVirtPtr.html#a7f4433b8fb29c5830151dc636bb53d28">isWrapped() function</a> can be used.</p>
<dl class="section note"><dt>Note</dt><dd>Wrapping regular pointers introduces a minor overhead in usage of virtual pointers and is therefore <b>disabled by default</b>. This feature can be enabled in <a class="el" href="config_8h.html">config.h</a>.</dd></dl>
<h2><a class="anchor" id="aMultiAlloc"></a>
Multiple allocators</h2>
<p>While not more than one instance of a memory allocator <em>type</em> should be defined, it is possible to define different allocators in the same program:</p>
<div class="fragment"><div class="line"><a class="code" href="singletonvirtmem_1_1CSdfatlibVirtMemAlloc.html">virtmem::CSdfatlibVirtMemAlloc&lt;&gt;</a> fatAlloc;</div>
<div class="line"><a class="code" href="classvirtmem_1_1CSPIRAMVirtMemAlloc.html">virtmem::CSPIRAMVirtMemAlloc&lt;&gt;</a> spiRamAlloc;</div>
<div class="line"></div>
<div class="line"><a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::CVirtPtr&lt;int, virtmem::CSdfatlibVirtMemAlloc&gt;</a> fatvptr;</div>
<div class="line"><a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::CVirtPtr&lt;int, virtmem::CSPIRAMVirtMemAlloc&gt;</a> spiramvptr;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// copy a kilobyte of data from SPI ram to a SD fat virtual memory pool</span></div>
<div class="line">virtmem::memcpy(fatvptr, spiramvptr, 1024);</div>
</div><!-- fragment --><h2><a class="anchor" id="aConfigAlloc"></a>
Configuring allocators</h2>
<p>The number and size of memory pages can be configured in <a class="el" href="config_8h.html" title="This header file contains several variables that can be used to customize virtmem. ">config.h</a>. Alternatively, these settings can be passed as a template parameter to the allocator. For more info, see the description about <a class="el" href="structvirtmem_1_1SDefaultAllocProperties.html" title="This struct contains default parameters for virtual memory pages. ">virtmem::SDefaultAllocProperties</a>.</p>
<h2><a class="anchor" id="aPointStructMem"></a>
Virtual pointers to `struct`/`class` data members</h2>
<p>It might be necessary to obtain a pointer to a member of a structure (or class) which resides in virtual memory. The way to obtain such a pointer with 'regular' memory is by using the address-of operator ('<code>@</code>'):</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *p = &amp;mystruct-&gt;x;</div>
</div><!-- fragment --><p>You may be tempted to do the same when the structure is in virtual memory:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> *p = &amp;vptr-&gt;x; <span class="comment">// Spoiler: Do not do this!</span></div>
</div><!-- fragment --><p>However, this should <b>never</b> be done! The problem is that the above code will set <code>p</code> to an address inside one of the virtual memory pages. This should be considered as a temporary storage location and the contents can be changed anytime.</p>
<p>To obtain a 'safe' pointer, one should use the getMembrPtr() function:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>myStruct { <span class="keywordtype">int</span> x; };</div>
<div class="line"><a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::CVirtPtr&lt;int, virtmem::CSdfatlibVirtMemAlloc&gt;</a> intvptr;</div>
<div class="line"></div>
<div class="line">intvptr = virtmem::getMembrPtr(mystruct, &amp;myStruct::x);</div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd>virtmem::getMembrPtr</dd></dl>
<h2><a class="anchor" id="aCoverloads"></a>
Overloads of some common C library functions for virtual pointers</h2>
<p>Overloads of some common C functions for dealing with memory and strings are provided by <code>virtmem</code>. They accept virtual pointers or a mix of virtual and regular pointers as function arguments. Please note that they are defined in the <a class="el" href="namespacevirtmem.html">virtmem namespace</a> like any other code from <code>virtmem</code>, hence, they will not "polute" the global namespace unless you want to (i.e. by using the <code>using</code> directive).</p>
<p>The following function overloads exist:</p><ul>
<li><code>memcpy</code></li>
<li><code>memset</code></li>
<li><code>memcmp</code></li>
<li><code>strncpy</code></li>
<li><code>strcpy</code></li>
<li><code>strncmp</code></li>
<li><code>strcmp</code></li>
<li><code>strlen</code></li>
</ul>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespacevirtmem.html#Coverloads">Overview of all overloaded functions</a>.</dd></dl>
<h2><a class="anchor" id="aTypeless"></a>
Typeless virtual pointers (analog to void*)</h2>
<p>When working with regular pointers, a <code>void</code> pointer can be used to store whatever pointer you like. With virtual pointers something similar can be achieved by using the base class for virtual pointers, namely <a class="el" href="classvirtmem_1_1CBaseVirtPtr.html" title="This is the base class of CVirtPtr and can be used for typeless pointers. ">virtmem::CBaseVirtPtr</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="singletonvirtmem_1_1CVirtPtr.html">virtmem::CVirtPtr&lt;int, virtmem::CSdfatlibVirtMemAlloc&gt;</a> virtIntPtr; <span class="comment">// shortcut</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> *intptr;</div>
<div class="line">virtIntPtr intvptr;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Store pointers in typeless pointer</span></div>
<div class="line"><span class="keywordtype">void</span> *voidptr = intptr;</div>
<div class="line"><a class="code" href="classvirtmem_1_1CBaseVirtPtr.html">virtmem::CBaseVirtPtr</a> basevptr = intvptr;</div>
<div class="line"></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Get it back</span></div>
<div class="line">intptr = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span> *<span class="keyword">&gt;</span>(voidptr);</div>
<div class="line">intvptr = <span class="keyword">static_cast&lt;</span>virtIntPtr<span class="keyword">&gt;</span>(basevptr);</div>
</div><!-- fragment --><h1><a class="anchor" id="examples"></a>
Examples</h1>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sun Oct 4 2015 21:27:03 for virtmem by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
